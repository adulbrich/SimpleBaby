import { render, screen, userEvent } from "@testing-library/react-native";
import Feeding from "@/app/(trackers)/feeding";
import { router } from "expo-router";
import { Alert } from "react-native";
import { getActiveChildId } from '@/library/utils';
import supabase from "@/library/supabase-client";


jest.mock("expo-router", () => {
    const replace = jest.fn();
    return ({
        router: {
            replace: replace,
        },
    });
});

jest.mock("@/library/supabase-client", () => {
    const insert = jest.fn(async () => ({success: true}));
    return ({
        from: () => ({
            insert: insert,
        })
    });
});

jest.mock("@/library/crypto", () => ({
    encryptData: async () => ""
}));

jest.mock("react-native", () => {
    const module = jest.requireActual("react-native");
    module.Alert.alert = jest.fn();
    return module;
});

jest.mock("@/library/utils", () => ({
    getActiveChildId: jest.fn(async () => ({ success: true }))
}));


describe("Track feeding screen", () => {

    beforeEach(() => {
        // to clear the .mock.calls array for each
        (Alert.alert as jest.Mock).mockClear();
        (router.replace as jest.Mock).mockClear();
        jest.spyOn(console, "error").mockClear();
    });

    test("Renders feeding tracking inputs", () => {
        render(<Feeding/>);

        expect(screen.getByTestId("feeding-data-entry")).toBeTruthy();
        expect(screen.getByTestId("feeding-note-entry")).toBeTruthy();
    });
    
    test("Renders form control buttons", () => {
        render(<Feeding/>);

        expect(screen.getByTestId("feeding-save-log-button")).toBeTruthy();
        expect(screen.getByTestId("feeding-reset-form-button")).toBeTruthy();
    });
    
    test("Refreshes on reset", async () => {
        render(<Feeding/>);

        const itemNameInput = screen.getByTestId("feeding-item-name");
        const amountInput = screen.getByTestId("feeding-amount");
        const resetButton = screen.getByTestId("feeding-reset-form-button");
        const noteInput = screen.getByTestId("feeding-note-entry")

        // type into the fields so we have something to clear
        await userEvent.type(itemNameInput, "Applesauce");
        await userEvent.type(amountInput, "4 oz");
        await userEvent.type(noteInput, "Baby disliked this");

        // check values are there before we reset
        expect(screen.getByDisplayValue("Applesauce")).toBeTruthy();
        expect(screen.getByDisplayValue("4 oz")).toBeTruthy();
        expect(screen.getByDisplayValue("Baby disliked this")).toBeTruthy();

        await userEvent.press(resetButton);

        // after reset, those values should no longer be in any input
        expect(screen.queryByDisplayValue("Applesauce")).toBeNull();
        expect(screen.queryByDisplayValue("4 oz")).toBeNull();
        expect(screen.queryByDisplayValue("Baby disliked this")).toBeNull();
    });
    
    test("Catch unfilled category/name/amount", async () => {
        render(<Feeding/>);
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe("Please provide category, item name, and amount");
    });
    
    test("catch utils.ts->getActiveChildID() error", async () => {
        const testErrorMessage = "testErrorGet";

        // library/utils.ts -> getActiveChild() should be mocked to return:
        // { success: /* falsy value */, error: /* string */ }
        // This should cause error handling in app/(trackers)/feeding.tsx -> saveFeedingLog()
        (getActiveChildId as jest.Mock).mockImplementationOnce(
            () => ({success: false, error: testErrorMessage})
        );

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by mock of app/library/utils.ts -> getActiveChildId()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> saveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Error: ${testErrorMessage}`);

        // error message generated by mock of app/library/utils.ts -> getActiveChildId()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[1][0]).toBe(`Failed to save feeding log: ${testErrorMessage}`);
    });
    
    test("catch supabase insert error", async () => {
        const testErrorMessage = "testErrorInsert";

        // supabase.from().insert() should be mocked to return:
        // {error: /* truthy string */}
        // This should cause error handling in app/(trackers)/feeding.tsx -> createFeedingLog()
        (supabase.from("").insert as jest.Mock).mockImplementationOnce(
            async () => ({ error: testErrorMessage })
        );

        jest.spyOn(console, "error").mockImplementation(() => null);  // suppress console warnings from within the tested code

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by supabase.from().insert()
        // console.error() called by app/(trackers)/feeding.tsx -> createFeedingLog()
        expect((console.error as jest.Mock).mock.calls[0][0]).toBe(`Error creating feeding log:`);
        expect((console.error as jest.Mock).mock.calls[0][1]).toBe(testErrorMessage);

        // error message generated by mock of supabase.from().insert()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Failed to save feeding log: ${testErrorMessage}`);
    });
    
    test("catch supabase(/encryption) error", async () => {
        const testErrorMessage = "testErrorInsert";
        const testError = new Error(testErrorMessage);

        // supabase.from().insert() should be mocked to throw an error:
        // This should cause error handling in app/(trackers)/feeding.tsx -> createFeedingLog()
        (supabase.from("").insert as jest.Mock).mockImplementationOnce(
            async () => { throw testError; }
        );

        jest.spyOn(console, "error").mockImplementation(() => null);  // suppress console warnings from within the tested code

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error generated by mock of supabase.from().insert()
        // console.error() called by app/(trackers)/feeding.tsx -> createFeedingLog()
        expect((console.error as jest.Mock).mock.calls[0][0]).toBe(`âŒ Encryption or insert failed:`);
        expect((console.error as jest.Mock).mock.calls[0][1]).toBe(testError);

        // error message generated by mock of supabase.from().insert()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Failed to save feeding log: Encryption or database error`);
    });

    test("Redirects user on successful submit", async () => {
        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // confirm that the expo-router was called to send the user back to the tracker page
        expect((router.replace as jest.Mock).mock.calls[0][0]).toBe(`/(tabs)`);
        expect((router.replace as jest.Mock)).toHaveBeenCalledTimes(1);

        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Feeding log saved successfully!`);
    });

});
