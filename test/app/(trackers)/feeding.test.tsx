import { render, screen, userEvent } from "@testing-library/react-native";
import Feeding from "@/app/(trackers)/feeding";
import { router } from "expo-router";
import { Alert } from "react-native";
import { getActiveChildId } from '@/library/utils';
import supabase from "@/library/supabase-client";


jest.mock("expo-router", () => {
    const replace = jest.fn();
    return ({
        router: {
            replace: replace,
        },
    });
});

jest.mock("@/library/supabase-client", () => {
    const insert = jest.fn();
    return ({
        from: () => ({
            insert: insert,
        })
    });
});

jest.mock("@/library/crypto", () => ({
    encryptData: async () => ""
}));

jest.mock("react-native", () => {
    const module = jest.requireActual("react-native");
    module.Alert.alert = jest.fn();
    return module;
});

jest.mock("@/library/utils", () => ({
    getActiveChildId: jest.fn()
}));


describe("Track sleep screen", () => {

    beforeEach(() => {
        // to clear the .mock.calls array for each
        (Alert.alert as jest.Mock).mockClear();
        (router.replace as jest.Mock).mockClear();
    });

    test("Renders sleep tracking inputs", () => {
        render(<Feeding/>);

        expect(screen.getByTestId("feeding-data-entry")).toBeTruthy();
        expect(screen.getByTestId("feeding-note")).toBeTruthy();
    });
    
    test("Renders form control buttons", () => {
        render(<Feeding/>);

        expect(screen.getByTestId("feeding-save-log-button")).toBeTruthy();
        expect(screen.getByTestId("feeding-reset-form-button")).toBeTruthy();
    });
    
    test("Refreshes on reset", async () => {
        render(<Feeding/>);
        await userEvent.press(
            screen.getByTestId("feeding-reset-form-button")
        );

        // confirm that the expo-router was called to send the same page, refreshed
        expect((router.replace as jest.Mock)).toHaveBeenCalledTimes(1);
        expect((router.replace as jest.Mock)).toHaveBeenLastCalledWith("./");
    });
    
    test("Catch unfilled category/name/amount", async () => {
        render(<Feeding/>);
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // confirm that the expo-router was called to send the same page, refreshed
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe("Please provide category, item name, and amount");
    });
    
    test("catch utils.ts->getActiveChildID() error", async () => {
        const testErrorMessage = "testErrorGet";

        // library/utils.ts -> getActiveChild() should be mocked to return:
        // { success: /* falsy value */, error: /* string */ }
        // This should cause error handling in app/(trackers)/feeding.tsx -> saveFeedingLog()
        (getActiveChildId as jest.Mock).mockImplementationOnce(
            () => ({success: false, error: testErrorMessage})
        );

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by mock of app/library/utils.ts -> getActiveChildId()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> saveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Error: ${testErrorMessage}`);

        // error message generated by mock of app/library/utils.ts -> getActiveChildId()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[1][0]).toBe(`Failed to save feeding log: ${testErrorMessage}`);
    });
    
    test("catch supabase insert error", async () => {
        const testErrorMessage = "testErrorInsert";

        // library/utils.ts -> getActiveChild() should be mocked to return:
        // {success: /* truthy value */}
        // This should cause no errors
        (getActiveChildId as jest.Mock).mockImplementation(
            () => ({success: true})
        );

        // supabase.from().insert() should be mocked to return:
        // {error: /* truthy string */}
        // This should cause error handling in app/(trackers)/feeding.tsx -> createFeedingLog()
        (supabase.from("").insert as jest.Mock).mockReturnValue(
            { error: testErrorMessage}
        );

        jest.spyOn(console, "error").mockImplementation(() => null);  // suppress console warnings from within the tested code

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by mock of supabase.from().insert()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Failed to save feeding log: ${testErrorMessage}`);
    });
    
    test("catch supabase(/encryption) error", async () => {
        const testErrorMessage = "testErrorInsert";
        const testError = new Error(testErrorMessage);

        // library/utils.ts -> getActiveChild() should be mocked to return:
        // {success: /* truthy value */}
        // This should cause no errors
        (getActiveChildId as jest.Mock).mockImplementation(
            () => ({success: true})
        );

        // supabase.from().insert() should be mocked to throw an error:
        // This should cause error handling in app/(trackers)/feeding.tsx -> createFeedingLog()
        (supabase.from("").insert as jest.Mock).mockImplementation(
            () => { throw testError; }
        );

        jest.spyOn(console, "error").mockImplementation(() => null);  // suppress console warnings from within the tested code
        (console.error as jest.Mock).mockClear();  // clear any previous calls

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error generated by mock of supabase.from().insert()
        // console.error() called by app/(trackers)/feeding.tsx -> createFeedingLog()
        expect((console.error as jest.Mock).mock.calls[0][1]).toBe(testError);

        // error message generated by mock of supabase.from().insert()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Failed to save feeding log: Encryption or database error`);
    });
    
    test("successfully submit feeding log", async () => {

        // library/utils.ts -> getActiveChild() should be mocked to return:
        // {success: /* truthy value */}
        // This should cause no errors
        (getActiveChildId as jest.Mock).mockImplementation(
            () => ({success: true})
        );

        // supabase.from().insert() should be mocked to return:
        // {error: /* falsy value */}
        // This should no errors
        (supabase.from("").insert as jest.Mock).mockReturnValue(
            {}
        );

        jest.spyOn(console, "error").mockImplementation(() => null);  // suppress console warnings from within the tested code

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by mock of supabase.from().insert()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((Alert.alert as jest.Mock).mock.calls[0][0]).toBe(`Feeding log saved successfully!`);
    });
    
    test("User redirected to home page after successful log", async () => {

        // library/utils.ts -> getActiveChild() should be mocked to return:
        // {success: /* truthy value */}
        // This should cause no errors
        (getActiveChildId as jest.Mock).mockImplementation(
            () => ({success: true})
        );

        // supabase.from().insert() should be mocked to return:
        // {error: /* falsy value */}
        // This should no errors
        (supabase.from("").insert as jest.Mock).mockReturnValue(
            {}
        );

        jest.spyOn(console, "error").mockImplementation(() => null);  // suppress console warnings from within the tested code

        render(<Feeding/>);

        // simulate user input
        await userEvent.press(
            screen.getByTestId("feeding-category-soft")
        );
        await userEvent.type(
            screen.getByTestId("feeding-item-name"),
            "test food"
        );
        await userEvent.type(
            screen.getByTestId("feeding-amount"),
            "test amount"
        );
        await userEvent.press(
            screen.getByTestId("feeding-save-log-button")
        );

        // error message generated by mock of supabase.from().insert()
        // Alert.alert() called by app/(trackers)/feeding.tsx -> handleSaveFeedingLog()
        expect((router.replace as jest.Mock).mock.calls[0][0]).toBe(`/(tabs)`);
    });

});
